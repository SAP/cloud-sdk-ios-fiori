import Combine
import OSLog
import SwiftUI
import Vision
#if canImport(VisionKit) && os(iOS) && !targetEnvironment(macCatalyst)
    import VisionKit
#endif
#if canImport(ConnectSDK)
    import ConnectSDK
#endif
#if canImport(RapidScanCompanion)
    import RapidScanCompanion
#endif

/// Manages various barcode scanner implementations, providing a unified interface for applications.
///
/// `BarcodeScannerManager` is an `ObservableObject` that allows SwiftUI views to react to changes
/// in scanner status, received barcodes, and pairing QR codes. It acts as a facade, delegating
/// operations to the currently active scanner instance (e.g., `VisionKitScanner`, `ProGloveScanner`).
///
/// ## Overview
/// The manager holds instances of all supported scanner types. An application can select an active
/// scanner type using `setActiveScanner(_:)`. Once a scanner is active, the manager proxies
/// calls like `startMonitoring()`, `triggerScan()`, `getPairingQRCode()`, etc., to that instance.
///
/// It also acts as a delegate (`BarcodeScannerDelegate`) for the active scanner, receiving status updates
/// and barcode data, which it then publishes for the application to consume via its `@Published` properties
/// or callback closures (`onStatusChanged`, `onBarcodeScanned`).
///
/// ## Usage
///
/// ### Initialization
/// Typically, you would use the shared singleton instance:
/// ```swift
/// @StateObject private var scannerManager = BarcodeScannerManager.shared
/// ```
/// Or, if you need custom configurations (e.g., for VisionKit):
/// ```swift
/// @StateObject private var scannerManager = BarcodeScannerManager(
///     recognizedDataTypes: [.barcode(symbologies: [.qr, .ean13])], // Specify symbologies for VisionKit
///     recognizesMultipleItems: false, // For VisionKit: stop after first scan
///     serviceUUID: "YOUR_CUSTOM_IPC_SERVICE_UUID" // Optional: For IPCMobile custom service
/// )
/// ```
///
/// ### Setting Callbacks
/// Assign closures to `onStatusChanged` and `onBarcodeScanned` to receive updates:
/// ```swift
/// .onAppear {
///     scannerManager.onStatusChanged = { status in
///         // Handle status change (e.g., update UI, show errors)
///         if case .error(let error) = status {
///             self.errorMessage = error.localizedDescription
///         }
///     }
///     scannerManager.onBarcodeScanned = { barcodeValue in
///         // Handle received barcode
///         self.scannedValue = barcodeValue
///         // If using VisionKit and it's a single scan, you might want to dismiss its view.
///     }
/// }
/// ```
///
/// ### Selecting and Activating a Scanner
/// Before using a scanner, it must be activated:
/// ```swift
/// func activateMyScanner(type: ScannerType) async {
///     do {
///         try await scannerManager.setActiveScanner(type)
///         // Scanner is now active and its startMonitoring() has been called.
///         // Status should update to .idle, .ready, or an error.
///     } catch {
///         // Handle activation error (e.g., scanner.startMonitoring() failed)
///         self.errorMessage = (error as? ScannerError)?.message ?? error.localizedDescription
///     }
/// }
/// ```

/// A platform-agnostic enum to represent data types for scanners, replacing VisionKit's RecognizedDataType.
public enum BarcodeDataType: Hashable {
    case barcode(symbologies: [VNBarcodeSymbology] = [])
    case text

    #if canImport(VisionKit) && os(iOS) && !targetEnvironment(macCatalyst)
        func toVisionKitType() -> DataScannerViewController.RecognizedDataType {
            switch self {
            case .barcode(let symbologies):
                return .barcode(symbologies: symbologies)
            case .text:
                return .text()
            }
        }
    #endif
}

@MainActor
public final class BarcodeScannerManager: ObservableObject {
    /// A shared singleton instance of the `BarcodeScannerManager` for convenient global access.
    /// Uses default initialization parameters.
    public static let shared = BarcodeScannerManager()

    /// The currently active scanner type (e.g., `.visionKit`, `.proGlove`).
    @Published public private(set) var activeScannerType: ScannerType?
    /// The current overall status of the active scanner or the manager itself.
    @Published public private(set) var status: ScannerStatus = .idle
    /// A Boolean indicating if the active scanner is currently in a `.scanning` state.
    @Published public private(set) var isScanning: Bool = false
    /// A SwiftUI `Image` containing the pairing QR code, if generated by the active scanner (e.g., ProGlove, IPCMobile).
    @Published public private(set) var pairingImage: Image?

    /// A callback closure that is invoked when a barcode is successfully scanned.
    /// The `String` parameter contains the decoded barcode data.
    public var onBarcodeScanned: ((String) -> Void)?
    /// A callback closure that is invoked when the `status` of the `BarcodeScannerManager` changes.
    public var onStatusChanged: ((ScannerStatus) -> Void)?

    /// The currently active `BarcodeScanner` instance. Internal use.
    private var activeScanner: (any BarcodeScanner)?
    #if canImport(VisionKit) && os(iOS) && !targetEnvironment(macCatalyst)
        /// The instance of the VisionKit (camera-based) scanner.
        private var visionKitScanner: VisionKitScanner
    #else
        private var visionKitScanner: VisionKitScanner?
    #endif
    
    #if canImport(ConnectSDK)
        /// The instance of the ProGlove hardware scanner.
        private let proGloveScanner: ProGloveScanner
    #endif
    #if canImport(RapidScanCompanion)
        /// The instance of the IPCMobile (RapidScan) hardware scanner.
        private let ipcMobileScanner: IPCMobileScanner
    #endif
    
    private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "cloud.sdk.ios.fiori.barcodescanner", category: "BarcodeScannerManager")

    /// Initializes a new `BarcodeScannerManager`.
    ///
    /// This setup allows for custom configuration of the internal scanners, particularly `VisionKitScanner`.
    /// - Parameters:
    ///   - recognizedDataTypes: For `VisionKitScanner`, a set of `DataScannerViewController.RecognizedDataType`
    ///                          to detect (e.g., `[.barcode()]`, `[.text()]`). Defaults to `[.barcode()]`.
    ///   - recognizesMultipleItems: For `VisionKitScanner`, a Boolean indicating whether the scanner should
    ///                              continue scanning after detecting an item. Defaults to `false`.
    ///   - serviceUUID: Optional: For `IPCMobileScanner`, a custom Bluetooth service UUID string.
    ///                  If `nil`, the IPCMobile SDK's default service UUID will be used.
    public init(
        recognizedDataTypes: Set<BarcodeDataType> = [.barcode()],
        recognizesMultipleItems: Bool = false,
        serviceUUID: String? = nil
    ) {
        self.logger.info("Initializing with VisionKit params: recognizedDataTypes=\(recognizedDataTypes), recognizesMultipleItems=\(recognizesMultipleItems). IPCMobile serviceUUID: \(serviceUUID ?? "Default")")
        #if canImport(VisionKit) && os(iOS) && !targetEnvironment(macCatalyst)
            self.visionKitScanner = VisionKitScanner(
                recognizedDataTypes: recognizedDataTypes,
                recognizesMultipleItems: recognizesMultipleItems
            )
        #else
            self.logger.warning("VisionKit not imported or not supported on this platform (e.g., Mac Catalyst). VisionKitScanner will not be available.")
        #endif
        #if canImport(ConnectSDK)
            self.proGloveScanner = ProGloveScanner()
            self.logger.info("ProGloveScanner instance created.")
        #else
            self.logger.warning("ConnectSDK for ProGlove not imported. ProGloveScanner will be a non-functional stub.")
        #endif
        #if canImport(RapidScanCompanion)
            self.ipcMobileScanner = IPCMobileScanner(serviceUUID: serviceUUID)
            self.logger.info("IPCMobileScanner instance created.")
        #else
            self.logger.warning("RapidScanCompanion for IPCMobile not imported. IPCMobileScanner will be a non-functional stub.")
        #endif
    }

    /// Sets and activates the specified scanner type.
    ///
    /// This method will:
    /// 1. Stop and deactivate any currently active scanner.
    /// 2. Set the new scanner type as active.
    /// 3. Call `startMonitoring()` on the new active scanner instance.
    /// The manager's `status` will be updated based on the outcome of these operations.
    ///
    /// - Parameter type: The `ScannerType` to activate. Pass `nil` to deactivate all scanners.
    /// - Throws: A `ScannerError` if the selected scanner type is not available or if its `startMonitoring()` method fails.
    public func setActiveScanner(_ type: ScannerType?) async throws {
        self.logger.info("Attempting to set active scanner to: \(type?.description ?? "None")")
        
        // Stop and clear previous scanner
        if let currentActive = activeScanner {
            self.logger.info("Stopping previously active scanner: \(currentActive.type.description)")
            currentActive.stopMonitoring()
            currentActive.delegate = nil
        }
        self.activeScanner = nil
        self.activeScannerType = nil
        self.pairingImage = nil
        
        // If type is nil, we are just deactivating. Set status to idle.
        guard let newType = type else {
            self.logger.info("Active scanner cleared.")
            self.status = .idle
            self.isScanning = false
            self.onStatusChanged?(self.status) // Explicitly call onStatusChanged after clearing
            return
        }

        guard let scannerInstance = getScannerInstance(for: newType) else {
            self.logger.error("Scanner instance for type \(newType.description) not available (SDK likely not imported).")
            self.status = .error(.notAvailable)
            throw ScannerError.notAvailable
        }

        self.activeScanner = scannerInstance
        self.activeScannerType = newType
        scannerInstance.delegate = self
        
        self.logger.info("Attempting to start monitoring for \(newType.description).")
        do {
            try await scannerInstance.startMonitoring()
            self.status = scannerInstance.currentStatus
            self.isScanning = self.status == .scanning
            self.onStatusChanged?(self.status)
            self.logger.info("Successfully called startMonitoring for \(newType.description). Current manager status: \(self.status.description)")
        } catch let error as ScannerError {
            logger.error("Failed to start monitoring for \(newType.description): \(error.localizedDescription)")
            self.status = .error(error)
            self.isScanning = false
            self.activeScanner = nil
            self.activeScannerType = nil
            throw error
        } catch {
            self.logger.error("Unexpected error during startMonitoring for \(newType.description): \(error.localizedDescription)")
            let unknownError = ScannerError(code: "start_monitoring_failed", message: error.localizedDescription)
            self.status = .error(unknownError)
            self.isScanning = false
            self.activeScanner = nil
            self.activeScannerType = nil
            throw unknownError
        }
    }

    /// Starts monitoring on the currently active scanner.
    public func startMonitoring() async throws {
        self.logger.info("Explicit startMonitoring called on BarcodeScannerManager.")
        guard let scanner = activeScanner else {
            self.logger.warning("No active scanner to start monitoring.")
            self.status = .error(.notAvailable)
            throw ScannerError.notAvailable
        }
        self.logger.info("Forwarding startMonitoring to active scanner: \(scanner.type.description)")
        try await scanner.startMonitoring()
    }

    /// Stops monitoring on the currently active scanner.
    public func stopMonitoring() {
        self.logger.info("Explicit stopMonitoring called on BarcodeScannerManager.")
        guard let scanner = activeScanner else {
            self.logger.info("No active scanner to stop.")
            if self.status != .idle { self.status = .idle }
            self.isScanning = false
            return
        }
        self.logger.info("Forwarding stopMonitoring to active scanner: \(scanner.type.description)")
        scanner.stopMonitoring()
        self.status = scanner.currentStatus
        self.isScanning = (self.status == .scanning)
        self.onStatusChanged?(self.status)
    }

    /// Triggers a scan operation on the currently active scanner.
    ///
    /// Behavior depends on the active scanner type:
    /// - `VisionKitScanner`: Starts the `DataScannerViewController`'s scanning process.
    /// - Hardware scanners (ProGlove, IPCMobile): Typically hardware-triggered.
    /// - Throws: `ScannerError.notAvailable` if no scanner is active, or a `ScannerError` from the active scanner's `triggerScan()`.
    public func triggerScan() async throws {
        self.logger.info("Explicit triggerScan called on BarcodeScannerManager.")
        guard let scanner = activeScanner else {
            self.logger.warning("No active scanner to trigger scan.")
            self.status = .error(.notAvailable)
            throw ScannerError.notAvailable
        }
        self.logger.info("Forwarding triggerScan to active scanner: \(scanner.type.description)")
        try await scanner.triggerScan()
    }

    /// Retrieves a pairing QR code from the active scanner, if supported (e.g., ProGlove, IPCMobile).
    /// The `pairingImage` published property is updated with the result.
    /// - Returns: A SwiftUI `Image` for pairing, or `nil` if not supported or generation fails.
    public func getPairingQRCode() -> Image? {
        self.logger.info("getPairingQRCode called on BarcodeScannerManager.")
        guard let scanner = activeScanner else {
            self.logger.warning("No active scanner for getPairingQRCode.")
            self.pairingImage = nil
            return nil
        }
        self.logger.info("Forwarding getPairingQRCode to active scanner: \(scanner.type.description)")
        let qrCode = scanner.getPairingQRCode()
        self.pairingImage = qrCode // Update published property
        if qrCode == nil, scanner.type != .visionKit { // VisionKit doesn't use QR pairing
            self.logger.warning("getPairingQRCode from \(scanner.type.description) returned nil. Expecting scanner to update its status if it's an error.")
        }
        return qrCode
    }

    /// Resets the currently active scanner to its initial state.
    public func resetActiveScanner() {
        self.logger.info("resetActiveScanner called.")
        if let scanner = activeScanner {
            self.logger.info("Resetting active scanner: \(scanner.type.description)")
            scanner.reset()
            scanner.delegate = nil
        }
        self.activeScanner = nil
        self.activeScannerType = nil
        self.pairingImage = nil
        self.status = .idle
        self.isScanning = false
        self.onStatusChanged?(self.status)
    }

    /// Sends display data to the active scanner, if it supports screen updates.
    /// - Parameter data: The `ScannerDisplayData` to send (e.g., `.proGlove(...)`, `.ipcMobile(...)`).
    public func updateScannerDisplay(data: ScannerDisplayData) {
        self.logger.info("updateScannerDisplay called on manager with data for \(self.activeScanner?.type.description ?? "No active scanner").")
        guard let scanner = activeScanner else {
            self.logger.warning("No active scanner to update display.")
            return
        }
        scanner.updateScannerDisplay(data: data)
    }

    /// Retrieves the `UIViewController` for the active scanner's UI, if applicable (primarily for VisionKit).
    /// - Returns: The scanner's `UIViewController`, or `nil`.
    public func getScannerView() -> UIViewController? {
        self.logger.info("getScannerView called on manager for \(self.activeScanner?.type.description ?? "No active scanner").")
        return self.activeScanner?.getScannerView()
    }

    /// Specifically retrieves the `VisionKitScanner` instance if it is the active scanner.
    /// - Returns: The `VisionKitScanner` instance, or `nil` if VisionKit is not active or not the current scanner type.
    public func getVisionKitScanner() -> VisionKitScanner? {
        #if canImport(VisionKit) && os(iOS) && !targetEnvironment(macCatalyst)
            guard self.activeScannerType == .visionKit, let scanner = activeScanner as? VisionKitScanner else {
                self.logger.debug("getVisionKitScanner: VisionKit is not the active scanner or type mismatch.")
                return nil
            }
            return scanner
        #else
            self.logger.debug("getVisionKitScanner: VisionKit not supported on this platform (e.g., Mac Catalyst).")
            return nil
        #endif
    }
    
    /// Returns an array of `ScannerType`s that are considered available on the device.
    /// - Returns: An array of available `ScannerType`s.
    public func availableScannerTypes() -> [ScannerType] {
        let availableTypes = ScannerType.allCases.filter { type in
            let instanceAvailable = self.getScannerInstance(for: type)?.isAvailable() ?? false
            return instanceAvailable
        }
        self.logger.info("Available scanner types: \(availableTypes.map(\.description))")
        return availableTypes
    }

    /// Retrieves the specific scanner instance for a given `ScannerType`.
    /// - Parameter type: The `ScannerType` for which to get the instance.
    /// - Returns: The `BarcodeScanner` instance, or `nil` if the SDK for that type is not imported/available.
    private func getScannerInstance(for type: ScannerType) -> (any BarcodeScanner)? {
        switch type {
        case .visionKit:
            #if canImport(VisionKit) && os(iOS) && !targetEnvironment(macCatalyst)
                return self.visionKitScanner
            #else
                self.logger.warning("Attempted to get VisionKit scanner instance, but VisionKit not supported on this platform (e.g., Mac Catalyst).")
                return nil
            #endif
        case .proGlove:
            #if canImport(ConnectSDK)
                return self.proGloveScanner
            #else
                self.logger.warning("Attempted to get ProGlove scanner instance, but ConnectSDK not imported.")
                return nil
            #endif
        case .ipcMobile:
            #if canImport(RapidScanCompanion)
                return self.ipcMobileScanner
            #else
                self.logger.warning("Attempted to get IPCMobile scanner instance, but RapidScanCompanion not imported.")
                return nil
            #endif
        }
    }

    /// Resets all managed scanner instances to their initial states and deactivates any active scanner.
    private func resetAllScanners() {
        #if canImport(ConnectSDK)
            self.proGloveScanner.reset()
            self.proGloveScanner.delegate = nil
        #endif
        #if canImport(RapidScanCompanion)
            self.ipcMobileScanner.reset()
            self.ipcMobileScanner.delegate = nil
        #endif
        #if canImport(VisionKit) && os(iOS) && !targetEnvironment(macCatalyst)
            self.visionKitScanner.reset()
            self.visionKitScanner.delegate = nil
        #else
            self.visionKitScanner?.reset()
            self.visionKitScanner?.delegate = nil
        #endif
        self.activeScanner = nil
        self.activeScannerType = nil
        self.status = .idle
        self.isScanning = false
        self.pairingImage = nil
        self.onStatusChanged?(self.status)
    }
}

/// Extension to make `BarcodeScannerManager` conform to `BarcodeScannerDelegate`.
extension BarcodeScannerManager: BarcodeScannerDelegate {
    /// Called by the active scanner when its status changes.
    public func barcodeScannerDidUpdateStatus(_ newStatus: ScannerStatus, for scanner: any BarcodeScanner) {
        guard scanner === self.activeScanner else { return }
        self.status = newStatus
        self.isScanning = self.status == .scanning
        if case .error = self.status {
            self.pairingImage = nil
        }
        self.onStatusChanged?(self.status)
    }

    /// Called by the active scanner when a barcode is successfully scanned.
    /// Invokes the manager's `onBarcodeScanned` callback with the barcode data.
    public func barcodeScannerDidReceiveBarcode(_ barcode: String, from scanner: any BarcodeScanner) {
        guard scanner.type == self.activeScanner?.type else {
            self.logger.info("Barcode received from a non-active or outdated scanner instance (\(scanner.type.description)). Ignoring.")
            return
        }
        self.logger.info("Manager received barcode from \(scanner.type.description): \(barcode)")
        self.onBarcodeScanned?(barcode)
    }
}

extension BarcodeDataType: CustomStringConvertible {
    public var description: String {
        switch self {
        case .barcode(let symbologies):
            return "barcode(symbologies: \(symbologies.map(\.rawValue)))"
        case .text:
            return "text"
        }
    }
}
