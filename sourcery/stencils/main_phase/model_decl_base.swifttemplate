<%- includeFile("../../.lib/Sources/utils/Array+String.swift") -%>
<%- includeFile("../../.lib/Sources/utils/Array+Variable.swift") -%>
<%- includeFile("../../.lib/Sources/utils/cloud_sdk_ios_sourcery_utils.swift") -%>
<%- includeFile("../../.lib/Sources/utils/String+Extensions.swift") -%>
<%- includeFile("../../.lib/Sources/utils/Type+Extensions.swift") -%>
<%- includeFile("../../.lib/Sources/utils/Variable+Extensions.swift") -%>
<%- includeFile("../../.lib/Sources/utils/swift-algorithms-copy/Combinations.swift") -%>
<%_ 

let models = types.protocols.filter({ $0.annotations["generated_component"] != nil })

for model in models {

    let componentProperties = model.flattenedComponentProperties(contextType: type)
    let styleName = model.componentStyleName

    let templateParameterDecls = [
            componentProperties.templateParameterDecls, 
            model.add_view_builder_paramsTemplateParameterDecls
        ].flatMap { $0 }.joined(separator: ", ")

  func optionalPropertySequences(_ t: Type) -> [[Variable]] {
      var sequences: [[Variable]] = []
      let optionalProperties = t.allVariables.filter({ $0.isOptional })
      guard optionalProperties.count > 0 else { return [] }
      for i in 1..<optionalProperties.count {
          sequences.append(contentsOf: optionalProperties.combinations(ofCount: i).map({ $0 }))
      }
      return sequences
  }

  let combinationsOfOptionals = optionalPropertySequences(model).map({ $0 })
  
  -%>
// sourcery:file:ViewModels/API/<%= model.componentName %>+API.generated.swift
import SwiftUI

public struct <%= model.componentName %><<%= templateParameterDecls %>> {
    <%= componentProperties.viewModifierPropertyDecls %>
    <%= model.add_env_propsDecls %>
    <%= model.add_public_propsDecls(indent: 1) %>
    <%= componentProperties.viewBuilderPropertyDecls %>

    public init(
        <%= componentProperties.viewBuilderInitParams %>
        ) {
            <%= componentProperties.viewBuilderInitParamAssignment %>
    }

    <%= componentProperties.resolvedViewModifierChain(type: model) %>
}

extension <%= model.componentName %> where <%= componentProperties.extensionConstrainedWhereConditionalContent %> {
    
    public init(model: <%= model.name %>) {
        self.init(<%= componentProperties.extensionModelInitParamsAssignment %>)
    }

    public init(<%= componentProperties.extensionModelInitParams %>) {
        <%= componentProperties.extensionModelInitParamsAssignments %>
    }
} 
// sourcery:end

// sourcery:file:ViewModels/Boilerplate/<%= model.componentName %>+View.generated.swift
//TODO: Copy commented code to new file: `FioriSwiftUICore/Views/<%= model.componentName %>+View.swift`
//TODO: Implement default Fiori style definitions as `ViewModifier`
//TODO: Implement <%= model.componentName %> `View` body

/// - Important: to make `@Environment` properties (e.g. `horizontalSizeClass`), internally accessible
/// to extensions, add as sourcery annotation in `FioriSwiftUICore/Models/ModelDefinitions.swift`
/// to declare a wrapped property
/// e.g.:  `// sourcery: add_env_props = ["horizontalSizeClass"]`

/*
import SwiftUI

// FIXME: - Implement Fiori style definitions

<%= model.fioriStyleImplEnumDecl(componentProperties: componentProperties) %>

// FIXME: - Implement <%= model.componentName %> View body

extension <%= model.componentName %>: View {
    public var body: some View { 
        <# View body #> 
    }
}
*/
// sourcery:end

// sourcery:file:ViewModels/Init+Extensions/<%= model.componentName %>+Init.generated.swift
import SwiftUI
<%_ 
    for optionalCombination in combinationsOfOptionals {
-%>

extension <%= model.componentName %> where <%= optionalCombination.extensionContrainedWhereEmptyView %> {
    public init(
        <%= componentProperties.extensionInitParamWhereEmptyView(scenario: optionalCombination) %>
        ) {
        self.init(
            <%= componentProperties.extensionInitParamAssignmentWhereEmptyView(scenario: optionalCombination) %>
        )
    }
}
<%_ } -%>

// sourcery:end
<%_ } -%>
