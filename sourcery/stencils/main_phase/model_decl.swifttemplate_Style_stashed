<%_ 

//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Algorithms open source project
//
// Copyright (c) 2020 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
//
//===----------------------------------------------------------------------===//

public struct Combinations<Base: Collection> {
  /// The collection to iterate over for combinations.
  public let base: Base
  
  @usableFromInline
  internal var k: Int
  
  @usableFromInline
  internal init(_ base: Base, k: Int) {
    self.base = base
    self.k = base.count < k ? -1 : k
  }

  @inlinable
  public var count: Int {
    func binomial(n: Int, k: Int) -> Int {
      switch k {
      case n, 0: return 1
      case n...: return 0
      case (n / 2 + 1)...: return binomial(n: n, k: n - k)
      default: return n * binomial(n: n - 1, k: k - 1) / k
      }
    }
    
    return k >= 0
      ? binomial(n: base.count, k: k)
      : 0
  }
}

extension Combinations: Sequence {
  public struct Iterator: IteratorProtocol {
    @usableFromInline
    internal let base: Base
    
    @usableFromInline
    internal var indexes: [Base.Index]
    
    @usableFromInline
    internal var finished: Bool
    
    internal init(_ combinations: Combinations) {
      self.base = combinations.base
      self.finished = combinations.k < 0
      self.indexes = combinations.k < 0
        ? []
        : Array(combinations.base.indices.prefix(combinations.k))
    }
    
    /// Advances the current indices to the next set of combinations. If
    /// `indexes.count == 3` and `base.count == 5`, the indices advance like
    /// this:
    ///
    ///     [0, 1, 2]
    ///     [0, 1, 3]
    ///     [0, 1, 4] *
    ///     // * `base.endIndex` reached in `indexes.last`
    ///     // Advance penultimate index and propagate that change
    ///     [0, 2, 3]
    ///     [0, 2, 4] *
    ///     [0, 3, 4] *
    ///     [1, 2, 3]
    ///     [1, 2, 4] *
    ///     [1, 3, 4] *
    ///     [2, 3, 4] *
    ///     // Can't advance without needing to go past `base.endIndex`,
    ///     // so the iteration is finished.
    @usableFromInline
    internal mutating func advance() {
      guard !indexes.isEmpty else {
        // Initial state for combinations of 0 elements is an empty array with
        // `finished == false`. Even though no indexes are involved, advancing
        // from that state means we are finished with iterating.
        finished = true
        return
      }
    
      let i = indexes.count - 1
      base.formIndex(after: &indexes[i])
      if indexes[i] != base.endIndex { return }

      var j = i
      while indexes[i] == base.endIndex {
        j -= 1
        guard j >= 0 else {
          // Finished iterating over combinations
          finished = true
          return
        }
        
        base.formIndex(after: &indexes[j])
        for k in indexes.indices[(j + 1)...] {
          indexes[k] = base.index(after: indexes[k - 1])
          if indexes[k] == base.endIndex {
            break
          }
        }
      }
    }
    
    @inlinable
    public mutating func next() -> [Base.Element]? {
      if finished { return nil }
      defer { advance() }
      return indexes.map { i in base[i] }
    }
  }
  
  public func makeIterator() -> Iterator {
    Iterator(self)
  }
}

extension Combinations: LazySequenceProtocol where Base: LazySequenceProtocol {}
extension Combinations: Equatable where Base: Equatable {}
extension Combinations: Hashable where Base: Hashable {}

//===----------------------------------------------------------------------===//
// combinations(count:)
//===----------------------------------------------------------------------===//

extension Collection {
  /// Returns a collection of combinations of this collection's elements, with
  /// each combination having the specificed number of elements.
  ///
  /// This example prints the different combinations of three from an array of
  /// four colors:
  ///
  ///     let colors = ["fuchsia", "cyan", "mauve", "magenta"]
  ///     for combo in colors.combinations(ofCount k: 3) {
  ///         print(combo.joined(separator: ", "))
  ///     }
  ///     // fuchsia, cyan, mauve
  ///     // fuchsia, cyan, magenta
  ///     // fuchsia, mauve, magenta
  ///     // cyan, mauve, magenta
  ///
  /// The returned collection presents combinations in a consistent order, where
  /// the indices in each combination are in ascending lexicographical order.
  /// That is, in the example above, the combinations in order are the elements
  /// at `[0, 1, 2]`, `[0, 1, 3]`, `[0, 2, 3]`, and finally `[1, 2, 3]`.
  ///
  /// If `k` is zero, the resulting sequence has exactly one element, an empty
  /// array. If `k` is greater than the number of elements in this sequence,
  /// the resulting sequence has no elements.
  ///
  /// - Parameter k: The number of elements to include in each combination.
  ///
  /// - Complexity: O(1)
  @inlinable
  public func combinations(ofCount k: Int) -> Combinations<Self> {
    assert(k >= 0, "Can't have combinations with a negative number of elements.")
    return Combinations(self, k: k)
  }
}

extension String {
    func capitalizingFirst() -> String {
        return prefix(1).capitalized + dropFirst()
    }

    func lowercasingFirst() -> String {
        return prefix(1).lowercased() + dropFirst()
    }
}
extension Type {

    var componentName: String {
        name.replacingOccurrences(of: "Model", with: "")
    }

    var componentNameAsPropertyDecl: String {
        componentName.lowercasingFirst()
    }

    var componentProperties: Array<Variable> {
        inheritedTypes.compactMap({ type[$0] }).flatMap({ $0.allVariables })
    }

    var componentStyleName: String {
        "\(componentName)Style"
    }

    var componentStyleNameAsPropertyDecl: String {
        componentStyleName.lowercasingFirst()
    }

    var stylePropertyDecl: String {
        "@Environment(\\.\(componentNameAsPropertyDecl)Style) var style: Any\(componentStyleName)"
    }

    var componentStyleConfigurationName: String {
        "\(componentStyleName)Configuration"
    }

    var fioriComponentStyleName: String {
        "Fiori\(componentStyleName)"
    }

    var fioriLayoutRouterName: String {
        "Fiori\(componentName)LayoutRouter"
    }

    var usage: String {
        "\(componentName) \(componentProperties.usage)"
    }

    var acmeUsage: String {
        "\(componentName) \(componentProperties.acmeUsage)"
    }

    var fioriStyleImplEnumDecl: String {
        """
        extension Fiori {
            enum \(componentName) {
                \(componentProperties.typealiasViewModifierDecls)

                // TODO: - substitute type-specific ViewModifier for EmptyModifier
                /*
                    // replace `typealias Subtitle = EmptyModifier` with: 

                    struct Subtitle: ViewModifier {
                        func body(content: Content) -> some View {
                            content
                                .font(.body)
                                .foregroundColor(.preferredColor(.primary3))
                        }
                    }
                */
                \(componentProperties.staticViewModifierPropertyDecls)
            }
        }
        """
    }
}

extension Variable {
    var swiftUITypeName: String {
        switch self.typeName.unwrappedTypeName {
        case "String", "[String]":
            return "Text"
        case "Image":
            return "Image"
        default:
            return "Never"
        }
    }

    var conditionalAssignment: String {
        if isOptional {
            return "\(name) != nil ? ViewBuilder.buildEither(first: \(toSwiftUI)) : ViewBuilder.buildEither(second: EmptyView())"
        } else {
            return toSwiftUI
        }
    }

    var toSwiftUI: String {
        switch self.typeName.unwrappedTypeName {
            case "String":
                return isOptional ? "Text(\(name)!)" : "Text(\(name))"
            case "[String]":
                return "Text(\(name).joined(separator: \", \"))"
            case "Image":
                return isOptional ? "\(name)!" : name
            default:
                return "\(swiftUITypeName)(\(name))" 
                    return "\(swiftUITypeName)(\(name))"
                return "\(swiftUITypeName)(\(name))" 
        }
    }

    var emptyDefault: String {
        if isOptional {
            return " = nil"
        } else if typeName.isArray {
            return " = []"
        } else {
            return ""
        }
    }
}

extension Array where Element: Variable {
    var templateParameterDecls: String {
        map({ "\($0.name.capitalizingFirst()): View"}).joined(separator: ", ")
    }

    var viewBuilderInitParams: String {
        map({ "@ViewBuilder \($0.name): @escaping () -> \($0.name.capitalizingFirst())"}).joined(separator: ",\n\t\t")
    }

    var viewBuilderPropertyDecls: String {
        map({ "private let _\($0.name): () -> \($0.name.capitalizingFirst())" }).joined(separator: "\n\t")
    }

    var viewModifierPropertyDecls: String {
        map({ "@Environment(\\.\($0.name)Modifier) private var \($0.name)Modifier" }).joined(separator: "\n\t")
    }

    var viewBuilderInitParamAssignment: String {
        map({ "self._\($0.name) = \($0.name)" }).joined(separator: "\n\t\t\t")
    }

    func configurationInitParams(component: String) -> String {
        map({ "\($0.name): _\($0.name)().modifier(\($0.name)Modifier.concat(Fiori.\(component).\($0.name))).typeErased" }).joined(separator: ",\n\t\t\t")
    }

    var configurationPropertyDecls: String {
        map({ "let \($0.name): AnyView" }).joined(separator: "\n\t")
    }

    var configurationPropertyViewBuilder: String {
        map({ "configuration.\($0.name)"}).joined(separator: "\n\t\t\t")
    }

    var staticViewModifierPropertyDecls: String {
        map({ "static let \($0.name) = \($0.name.capitalizingFirst())()" }).joined(separator: "\n\t\t")
    }

    var typealiasViewModifierDecls: String {
        map({ "typealias \($0.name.capitalizingFirst()) = EmptyModifier" }).joined(separator: "\n\t\t")
    }

    var extensionContrainedWhereEmptyView: String {
        map({ "\($0.name.capitalizingFirst()) == EmptyView" }).joined(separator: ", ")
    }

    var extensionConstrainedWhereConditionalContent: String {
        map({ "\($0.name.capitalizingFirst()) == \($0.isOptional ? "_ConditionalContent<\($0.swiftUITypeName), EmptyView>" : $0.swiftUITypeName)"}).joined(separator: ",\n\t\t")
    }

    var extensionModelInitParams: String {
        map({ "\($0.name): \($0.typeName.name)\($0.emptyDefault)" }).joined(separator: ", ")
    }

    var extensionModelInitParamsAssignment: String {
        map({ "\($0.name): model.\($0.name)"}).joined(separator: ", ")
    }

    var extensionModelInitParamAssignments: String {
        map({ "self._\($0.name) = { \($0.conditionalAssignment) }" }).joined(separator: "\n\t\t")
    }

    var usage: String {
        reduce(into: Array<String>(), { prev, next in 
            let label = prev.count > 0 ? "\(next.name):" : ""
            prev.append("\(label) {\n\t\t\tconfiguration.\(next.name)\n\t\t}")
        }).joined(separator: " ")
    }

    var acmeUsage: String {
        reduce(into: Array<String>(), { prev, next in 
            let label = prev.count > 0 ? "\(next.name):" : ""
            prev.append("""
            \(label) {
                        VStack {
                            configuration.\(next.name)
                            Acme\(next.name.capitalizingFirst())View()
                        }
                    }
            """)
        }).joined(separator: " ")
    } 

    func extensionInitParamWhereEmptyView(scenario: Array<Element>) -> String {
        var output: Array<String> = []
        for variable in self {
            if !scenario.contains(variable) {
                output.append("@ViewBuilder \(variable.name): @escaping () -> \(variable.name.capitalizingFirst())")
            } 
        }
        return output.joined(separator: ",\n\t\t")
    }

    func extensionInitParamAssignmentWhereEmptyView(scenario: Array<Element>) -> String {
        var output: Array<String> = []
        for variable in self {
            if scenario.contains(variable) {
                output.append("\(variable.name): { EmptyView() }")
            } else {
                output.append("\(variable.name): \(variable.name)")
            }
        }
        return output.joined(separator: ",\n\t\t\t")
    }
}

let models = types.protocols.filter({ $0.annotations["generated_component"] != nil })

for model in models {

    let componentProperties = model.componentProperties
    let styleName = model.componentStyleName


  func optionalPropertySequences(_ t: Type) -> [[Variable]] {
      var sequences: [[Variable]] = []
      let optionalProperties = t.allVariables.filter({ $0.isOptional })
      guard optionalProperties.count > 0 else { return [] }
      for i in 1..<optionalProperties.count {
          sequences.append(contentsOf: optionalProperties.combinations(ofCount: i).map({ $0 }))
      }
      return sequences
  }

  let combinationsOfOptionals = optionalPropertySequences(model).map({ $0 })
  
  -%>
// sourcery:file:ViewModels/API/<%= model.componentName %>+View.generated.swift
import SwiftUI

public struct <%= model.componentName %><<%= componentProperties.templateParameterDecls %>>: View {
    <%= componentProperties.viewModifierPropertyDecls %>
    <%= model.stylePropertyDecl %>

    <%= componentProperties.viewBuilderPropertyDecls %>

    public init(
        <%= componentProperties.viewBuilderInitParams %>
        ) {
            <%= componentProperties.viewBuilderInitParamAssignment %>
    }

    public var body: some View {
        let configuration = <%= model.componentStyleConfigurationName %>(
            <%= componentProperties.configurationInitParams(component: model.componentName) %>
        )
        return style.makeBody(configuration: configuration)
    }   
}

extension <%= model.componentName %> where <%= componentProperties.extensionConstrainedWhereConditionalContent %> {
    
    public init(model: <%= model.name %>) {
        self.init(<%= componentProperties.extensionModelInitParamsAssignment %>)
    }

    public init(<%= componentProperties.extensionModelInitParams %>) {
        <%= componentProperties.extensionModelInitParamAssignments %>
    }
} 

// MARK: - <%= styleName %> Protocol
public protocol <%= styleName %> {
    associatedtype Body : View
    func makeBody(configuration: Self.Configuration) -> Self.Body
    typealias Configuration = <%= model.componentStyleConfigurationName %>
}

public struct <%= model.componentStyleConfigurationName %> {
    <%= componentProperties.configurationPropertyDecls %>
}

// MARK: - <%= styleName %> Environment Utility
extension View {
    public func <%= model.componentNameAsPropertyDecl %>Style<S>(_ style: S) -> some View
        where S: <%= styleName %> {
            self.environment(\.<%= model.componentNameAsPropertyDecl %>Style, Any<%= styleName %>(style))
        }
}

// MARK: - Type Erased <%= styleName %>
public struct Any<%= styleName %>: <%= styleName %> {
    private let _makeBody: (Self.Configuration) -> AnyView

    init<Style: <%= styleName %>>(_ style: Style) {
        self._makeBody = style.makeBodyTypeErased
    }

    public func makeBody(configuration: Self.Configuration) -> AnyView {
        return self._makeBody(configuration)
    }
}

extension <%= styleName %> {
    func makeBodyTypeErased(configuration: Self.Configuration) -> AnyView {
        AnyView(self.makeBody(configuration: configuration))
    }
}

// MARK: - <%= styleName %> Environment Key
extension EnvironmentValues {
    var <%= model.componentNameAsPropertyDecl %>Style: Any<%= styleName %> {
        get { return self[<%= styleName %>Key.self]  }
        set { self[<%= styleName %>Key.self] = newValue }
    }
}

public struct <%= model.componentStyleName %>Key: EnvironmentKey {
    public static let defaultValue: Any<%= styleName %> = Any<%= model.componentStyleName %>(Fiori<%= styleName %>())
}
// sourcery:end

// sourcery:file:ViewModels/Boilerplate/<%= model.componentName %>+StyleImpl+TODO.generated.swift

// TODO: - Extend <%= model.componentName %> to implement LayoutRouter, Layout, and Style in separate file
// Place at FioriSwiftUICore/Views/StyleImplementations/<%= model.componentName %>+StyleImpl.swift

// TODO: - Uncomment and implement Fiori style definitions

/*
<%= model.fioriStyleImplEnumDecl %>
*/

/*
// TODO: - Uncomment if View has consistent layout, regardless of context, e.g. `horizontalSizeClass`, etc.

/// For single-layout components, this is where the `View.Body` should be implemented
public struct <%= model.fioriComponentStyleName %> : <%=model.componentStyleName %> {
    public func makeBody(configuration: Configuration) -> some View {
        VStack {
            <%= componentProperties.configurationPropertyViewBuilder %>
        }
        .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .center)
    }
}
*/
/*
// TODO: - Uncomment if View has multiple layouts, depending upon context

/// A pass-through `View.Body` implementation, which applies the `*LayoutRouter` `ViewModifier`
public struct <%= model.fioriComponentStyleName %>: <%= styleName %> {
    public func makeBody(configuration: Configuration) -> some View {
        <%= model.usage %>
        .modifier(<%= model.fioriLayoutRouterName %>())
    }
}

/// Example layout router, which selects the correct `Style` based on `horizontalSizeClass`
/// May be modified, replaced, or chained.
public struct <%= model.fioriLayoutRouterName %>: ViewModifier {
    
    @Environment(\.horizontalSizeClass) private var horizontalSizeClass

    @ViewBuilder
    public func body(content: Content) -> some View {
        if horizontalSizeClass == .some(.compact) {
            content.<%= model.componentStyleNameAsPropertyDecl %>(<%= model.fioriComponentStyleName %>.CompactLayout())
        } else {
            content.<%= model.componentStyleNameAsPropertyDecl %>(<%= model.fioriComponentStyleName %>.RegularLayout())
        }
    }
}

extension <%= model.fioriComponentStyleName %> {
    public struct CompactLayout: <%= model.componentStyleName %> {
        public func makeBody(configuration: Configuration) -> some View {
            VStack {
                <%= componentProperties.configurationPropertyViewBuilder %>
            }
            .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .center)
                    .padding([.top, .bottom], 8)
        }
    }

    public struct RegularLayout: <%= model.componentStyleName %> {
        public func makeBody(configuration: Configuration) -> some View {
            HStack {
                <%= componentProperties.configurationPropertyViewBuilder %>
            }
            .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .center)
                    .padding([.top, .bottom], 8)
        }
    }
}
*/
/*
// TODO: - Creating Application-specific Style, while leveraging Fiori Layouts

/// Example Custom Style implementation, using pass-through technique from above.  
/// Developer may pass the `AnyView` from the `Configuration` directly through, 
/// contain it in a super-structure, or replace it entirely.
/// Invoking the `*LayoutRouter` `ViewModifier` causes the standard body implementation
/// to attempt to layout the supplied view.
public struct Acme<%= model.componentStyleName %>: <%= model.componentStyleName %> {
    
    @ViewBuilder
    public func makeBody(configuration: Configuration) -> some View {
        <%= model.acmeUsage %>
        .modifier(FioriKeyValueItemSizeClassModifier())
    }
}
*/

// sourcery:end

// sourcery:file:ViewModels/Init+Extensions/<%= model.componentName %>+Init.generated.swift
import SwiftUI
<%_ 
    for optionalCombination in combinationsOfOptionals {
-%>

extension <%= model.componentName %> where <%= optionalCombination.extensionContrainedWhereEmptyView %> {
    public init(
        <%= componentProperties.extensionInitParamWhereEmptyView(scenario: optionalCombination) %>
        ) {
        self.init(
            <%= componentProperties.extensionInitParamAssignmentWhereEmptyView(scenario: optionalCombination) %>
        )
    }
}
<%_ } -%>

// sourcery:end
<%_ } -%>
